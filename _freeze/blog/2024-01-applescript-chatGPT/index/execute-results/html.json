{
  "hash": "f469ee2e65c422b5ad7559ddedc7e715",
  "result": {
    "markdown": "---\ntitle: \"Using AppleScript To Turn Safari Into a Web Scraping Robot\"\neditor: visual\nauthor: John Goldin\ndate: '2024-01-27'\ndraft: true\nimage: \"applescript_code.png\"\nimage-alt: \"a sample of AppleScript code\"\nimage-height: \"100px\"\nslug: applescript-safari-R\ncategories:\n  - R\n  - Ukraine\n  - chatGPT\ntags:\n  - R\n  - Ukraine\n  - chatGPT\ndescription: |\n  With extensive help from chatGPT, I created an AppleScript that would download Ukraine web pages that contain Ministry of Defence estimates of Russian losses day by day. \nlayout: single\nformat:\n  html:\n    code-fold: true\n    code-summary: \"Show the code\"\n    toc: true\n    fig-cap-location: top\nexecute: \n  echo: false\n---\n\n::: {.cell}\n\n:::\n\n\nLast Spring I did a [post](/blog/2023-05-12-ukraine-stats/) to show the trend in Russian losses as reported by the Ukrainian Ministry of Defence. I've been redoing it witih updated data every week or so. Originally I was dowloading the HTML pages containing the daily reports using the `readr::read_lines()` function.\n\nIn December Ukraine switched from a Ministry of Defence website to a more general public information portal (at <https://www.kmu.gov.ua/en/tag/oborona>). I quickly discovered that the new server would not allow access via `readr::read_lines()`. I get a message that says \"We apologize for the inconvenience...but your activity and behavior on this site made us think that you are a bot.\" They've got a point. Presumably they think I might be an ill-intentioned Russkie. I was able to continue to access the page via Safari. So I thought Imight be able to continue to get batches of updates through Safari by turning Safari into a bot.\n\nTo do that I need to create a script in AppleScript. Although I've had some small encounters with AppleScript since it appeared in the early 1990's, I've never done real work with it. So my first problem was that I didn't really know how to code with AppleScript. But now I know something that does: chatGPT.\n\nI've using chatGPT to help with R coding and I've installed GitHub co-pilot into RStudio. It's very helpful. But I didn't know whether it would help at all with Safari and AppleScript.\n\nI started small. In the chatGPT I made a simple request:\n\n> Using MacOS AppleScript script editor, create a script that will open Safari and open a web page with part of the URL taken from the current date.\n\nI got some AppleScript to start out. I needed to fetch pages for a range of dates so I got involved in the issue of how to get that set up. The process didn't go very smoothly. So I decided I needed to start over while giving chatGPT a more concrete and explicit statement of what I wanted to do. Here's my second attempt:\n\n> Let's start over. I want to get a url that ends with a date in the form of DDMMYYYY. An example of the URL is: https://www.kmu.gov.ua/en/news/zahalni-boiovi-vtraty-protyvnyka-z-24022022-po-06012024 I want to ask for input of a date and then return with a url like this that ends with that date.\n\nThis worked a little better. Usually chatGPT would respond with some code along with an almost line by line explantion of what the code was intended to do. It gave me lots of commentary on what was happening with the code. I got into a rythym. After chatGPT would suggest some code I would change it a bit to move it toward the direction I was going for. Not infrequently that would produce an error. Next I would quote the error message to chatGPT, chatGPT would apologize and then give me something else to try. Over a period of several hours I got closer and closer to something that fit what I needed.\n\nI ended up with a script that asked for a starting and ending date, opened the Ukraine reporting page for each date in the range, and saved the HTML page to a file. I was able to run it and get the results I wanted. I was able to get the data I needed for my [Ukraine stats page](/blog/2023-05-12-ukraine-stats/).\n\nI used it to get the stats for 200 days. After I added another small batch of dates, I again got an message that the web site suspected I was a bot. But a day later I was able to get another batch of dates. So long as I limit the volume of requests in a short space of time, it seems to work fine.\n\nJust to give some idea of what AppleScript code looks like, here is some code takes a starting and ending date and then creates a list of all the dates in that range.\n\n![](applescript_code_fragment1.png){fig-alt=\"A sample of AppleScript code that shows how it is formatted.\" fig-align=\"center\"}\n\nThe way in which chatGPT can explain the code it has created is a huge help. There's a line later in the script that runs a shell script to copy a file. I wasn't sure exactly what was going on in that line so I asked chatGPT to explain it to me. Here's what it said:\n\n> Certainly! Let's break down what this line in the AppleScript is doing:\n>\n> ``` applescript\n> do shell script \"mkdir -p \" & quoted form of (POSIX path of folderPath) & \"; echo \" & quoted form of theSource & \" > \" & quoted form of posixPath\n> ```\n>\n> This line of code is executing a shell command from within AppleScript. It is composed of two main parts:\n>\n> 1.  **Creating the Directory (if needed)**:\n>     -   `mkdir -p`: This is a shell command that creates a directory. The `-p` flag ensures that the command does not throw an error if the directory already exists and also allows the creation of nested directories as needed.\n>     -   `& quoted form of (POSIX path of folderPath)`: This AppleScript part concatenates the `mkdir -p` command with the path where the file should be saved. The `folderPath` is an AppleScript variable that holds the path in AppleScript's path format (colon-separated). `POSIX path of folderPath` converts this path to a POSIX path (slash-separated, which is the standard format in shell environments). `quoted form of` ensures that the path is correctly quoted in case it contains spaces or special characters.\n> 2.  **Writing the Source Code to a File**:\n>     -   `;`: This is a semicolon used in shell commands to separate multiple commands. It allows you to execute several commands in sequence.\n>     -   `echo`: This is another shell command that outputs the string that follows it.\n>     -   `& quoted form of theSource`: This concatenates the `echo` command with the source code of the web page. `theSource` is a variable in your AppleScript that holds the HTML source code of the page.\n>     -   `>`: This is a redirection operator in shell commands. It takes the output of the command on its left (in this case, the `echo` command) and writes it to the file specified on its right.\n>     -   `& quoted form of posixPath`: Finally, this part specifies the file to which the source code should be written. `posixPath` is the full path to the file, and again, `quoted form of` is used to handle spaces or special characters in the path.\n>\n> In summary, this line in your script is creating the necessary directory (if it doesn't already exist) and then writing the HTML source code of a web page to a file at the specified path. This is a common technique to perform file and directory operations from within AppleScript, leveraging the power of shell commands.\n\n\n::: {.cell}\n\n```{.javascript .cell-code  code-fold=\"true\" code-summary=\"Show the AppleScript code\"}\non generateDates(startDate, endDate)\n\tset currentDate to startDate\n\tset dateList to {}\n\t\n\trepeat until currentDate > endDate\n\t\tcopy currentDate to the end of dateList\n\t\tset currentDate to currentDate + 1 * days\n\tend repeat\n\t\n\treturn dateList\nend generateDates\n```\n:::\n\n::: {.cell}\n\n```{.javascript .cell-code  code-fold=\"true\" code-summary=\"Show the full AppleScript code\"}\n-- Function to prompt for date input and return it as a date object\non promptForDate(promptMessage)\n\t-- Get the current date\n\tset firstDate to ((current date) - 7 * days)\n\tset currentDay to day of firstDate as number\n\tset currentMonth to month of firstDate as number\n\tset currentYear to year of firstDate as number\n\t\n\t-- Format the current date as MMDDYYYY\n\tset defaultDate to my zeroPad(currentMonth) & my zeroPad(currentDay) & currentYear as string\n\t\n\tset inputDate to text returned of (display dialog promptMessage default answer defaultDate)\n\t\n\t-- Length check for the input\n\tif length of inputDate is not 8 then\n\t\tdisplay dialog \"Invalid date. Please enter 8 digits for the date as MMDDYYYY.\" buttons {\"OK\"} default button 1\n\t\treturn promptForDate(promptMessage) -- Recursively call the function until valid input is provided\n\tend if\n\t\n\t-- Convert the string to a date object\n\tset dayPart to text 1 thru 2 of inputDate\n\tset monthPart to text 3 thru 4 of inputDate\n\tset yearPart to text 5 thru 8 of inputDate\n\tset formattedDateString to dayPart & \"/\" & monthPart & \"/\" & yearPart\n\t\n\treturn date formattedDateString\nend promptForDate\n\n-- Function to generate all dates between two given dates\non generateDates(startDate, endDate)\n\tset currentDate to startDate\n\tset dateList to {}\n\t\n\trepeat until currentDate > endDate\n\t\tcopy currentDate to the end of dateList\n\t\tset currentDate to currentDate + 1 * days\n\tend repeat\n\t\n\treturn dateList\nend generateDates\n\n\n\n-- Main script execution\ntell application \"System Events\"\n\tlog \"And away we go...\" & ((current date) as string)\n\t\n\tset startDate to my promptForDate(\"Enter the start date (MMDDYYYY):\")\n\tset endDate to my promptForDate(\"Enter the end date (MMDDYYYY):\")\n\t\n\tset allDates to my generateDates(startDate, endDate)\n\t\n\t-- Check on the number of dates we are about to process\n\tset userResponse to button returned of (display dialog \"Count of dates: \" & (count of allDates) & \" from \" & (item 1 of allDates) & \" to \" & (item (count of allDates) of allDates) buttons {\"Cancel\", \"OK\"} default button 2)\n\t\nend tell\nrepeat with aDate in allDates\n\t-- log \"in loop \" & aDate\n\ttell application \"Safari\"\n\t\tset formattedDateDMY to my zeroPad(day of aDate as number) & my zeroPad(month of aDate as number) & (year of aDate as number)\n\t\tset formattedDateYMD to (year of aDate as number) & \"-\" & my zeroPad(month of aDate as number) & \"-\" & my zeroPad(day of aDate as number)\n\t\t-- log \"formattedDateDMY is \" & formattedDateDMY\n\t\t-- log \"formattedDateYMD is \" & formattedDateYMD\n\t\t\n\t\t-- for debugging, verify before opening web page\n\t\t-- set userResponse to button returned of (display dialog \"Verify date DMY: \" & formattedDateDMY & \"Verify date YMD: \" & formattedDateYMD buttons {\"Cancel\", \"OK\"} default button 2)\n\t\t\n\t\tset theURL to \"https://www.kmu.gov.ua/en/news/zahalni-boiovi-vtraty-protyvnyka-z-24022022-po-\" & formattedDateDMY\n\t\t\n\t\tlog \"URL: \" & theURL\n\t\t\n\t\tactivate\n\t\topen location theURL\n\t\tdelay 5 -- Adjust the delay as necessary\n\t\t-- Get the source code from Safari\n\t\tset theSource to source of document 1\n\t\t-- log \"after set theSource to source of document 1\"\n\tend tell\n\t-- Assuming theSource contains the HTML source code\n\t\n\t-- String to search for\n\tset searchString to \">404</div>\"\n\t\n\t-- Use AppleScript's text item delimiters to check if the string is in the source\n\tset AppleScript's text item delimiters to searchString\n\tset textItems to text items of theSource\n\tset AppleScript's text item delimiters to \"\" -- Reset the delimiters\n\t\n\t-- Check if the string indicating 404 error was found\n\tif (count of textItems) > 1 then\n\t\tlog \"404 NOT FOUND:\" & theURL\n\t\t-- Handle the case where the string is found, i.e., don't save the page source\n\telse\n\t\t-- Handle the case where the string is not found\n\t\t-- Define the file path and name\n\t\tset homePath to path to home folder as string\n\t\tset folderPath to homePath & \"Documents:R_local_repos:ukrainestats:ukr_reports:\"\n\t\tset fileName to \"ukraine_stats_\" & formattedDateYMD & \".html\"\n\t\tset fullFilePath to folderPath & fileName\n\t\t\n\t\t-- log \"fullFilePath is \" & fullFilePath\n\t\t\n\t\t-- Replace colons with slashes for shell command\n\t\tset posixPath to POSIX path of fullFilePath\n\t\t\n\t\tlog posixPath\n\t\t\n\t\t-- Save the source code\n\t\tdo shell script \"mkdir -p \" & quoted form of (POSIX path of folderPath) & \"; echo \" & quoted form of theSource & \" > \" & quoted form of posixPath\n\tend if\n\t\n\ttell application \"Safari\"\n\t\t-- Check if there is at least one window open\n\t\tif (count of windows) > 0 then\n\t\t\tset currentWindow to front window\n\t\t\t\n\t\t\t-- Check if there is at least one tab open in the current window\n\t\t\tif (count of tabs of currentWindow) > 0 then\n\t\t\t\tset currentTab to current tab of currentWindow\n\t\t\t\tset tabName to name of currentTab\n\t\t\t\t\n\t\t\t\t-- Log the name of the current tab\n\t\t\t\t-- log \"Closing tab: \" & tabName\n\t\t\t\t\n\t\t\t\t-- Close the current tab\n\t\t\t\ttell currentWindow to close currentTab\n\t\t\tend if\n\t\tend if\n\tend tell\n\t\nend repeat\n\n-- Function to add a leading zero to single-digit numbers\non zeroPad(anumber)\n\tif anumber < 10 then\n\t\treturn \"0\" & (anumber as string)\n\telse\n\t\treturn anumber as string\n\tend if\nend zeroPad\n\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}